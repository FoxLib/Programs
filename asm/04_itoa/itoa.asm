
        org     100h

        mov     ax, -2334
        call    itoa
        int     20h

; bx - указатель, где будет строка (временная)
; необходимо 5 символов места
itoa:   lea     si, [bx + 5]        ; Переместить указатель в конец
        mov     [si], byte 0        ; Поставить там символ завершения вывода на экран
        test    ax, $8000           ; Тест на знак
        jns     .L1                 ; Это не знаковое, пропуск

        neg     ax                  ; AX = -AX
        push    ax                  ; Сохранить число AX
        mov     ah, 0Eh             ; AH=0e печать одного символа
        mov     al, '-'             ; Этот символ '-'
        int     10h                 ; Вызов Биос-функции печати символа
        pop     ax                  ; Восстановить число AX

.L1:    mov     bx, 10              ; bx=10 (на что делим)
.L2:    xor     dx, dx              ; dx=очистить обязательно!
        div     bx                  ; делим ax / bx, получаем ax, остаток dx
        add     dl, '0'             ; dl = 0..9, приводим к ASCII виду '0'..'9'
        dec     si                  ; Сдвиг курсора налево
        mov     [si], dl            ; Запись полученного символа
        and     ax, ax              ; Проверить AX на 0
        jne     .L2                 ; Если еще не 0, есть символы еще слева

.L3:    lodsb                       ; Загрузить символ из [SI]
        and     al, al              ; Проверка AL=0
        je      .L4                 ; Если да, завершить
        mov     ah, 0Eh             ; Код вывода символа
        int     10h                 ; Вывод символа через BIOS
        jmp     .L3

.L4:    ret
